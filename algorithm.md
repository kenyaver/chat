# Algorithm

## Сервер:

### 1. Основной поток.
    1.1. Запуск с параметрами (порт).
    1.2. Сервер начинает слушать порт.
    1.3. Сервер ожидает одно из событий (сигнал о завершении или подключение нового клиента).
        1.3.1. Если сервер получает сигнал о завершении работы:
            1.3.1.1. Сервер уведомляет все активные потоки о завершении работы.
            1.3.1.2. Сервер переходит к пункту 1.4.
        1.3.2. Если сервер получает событие подключения клиента:
            1.3.2.1. Работа с клиентом переводится в отдельный поток (переход к пункту 3).
            1.3.2.2. Основной поток возвращется к пункту 1.3.
    1.4. Сервер ожидает завершения всех потоков.
    1.5. Сервер завершает работу.

Условные обозначения:
оффлайн-файл - offline/{username}.txt

### 2. Поток обработки клиента.
    2.1. Сервер получает первую команду.
    2.2. Сервер записывает информацию о клиенте в список клиентов (SRC_username, socket, создаются очередь таймеров и буффер неподтвержденных команд).
    2.3. Если есть оффлайн-команды для клиента (в оффлайн-файле для клиента есть команды):
        2.3.1. Отправляются все оффлайн-команды (из оффлайн-файла).
        2.3.2. Сервер очищает оффлайн-файл.
    2.4. Сервер выполняет пункт 2.5.1.1.
    2.5. Сервер ждет событий по сокету клиента или от дескриптора таймера.
        2.5.1. Если сервер получает команду:
            2.5.1.1. Если type == 0:
                2.5.1.1.1. Если клиент с username == DST_username есть в списке клиентов:
                    2.5.1.1.1.1. Команда отправляется клиенту-получателю (клиенту с таким username).
                    2.5.1.1.1.2. Команда записывается в буффер неподтвержденных команд для клиента-получателя.
                    2.5.1.1.1.3. Таймер добавляется в очередь таймеров для этого клиента-получателя.
                    2.5.1.1.1.4. Если для этого клиента-получателя очередь таймеров пуста:
                        2.5.1.1.1.4.1. Заводится таймер для отправляемой команды.
                2.5.1.1.2. Если клиента с username == DST_username нет в списке клиентов:
                    2.5.1.1.2.1. type команды изменяется на 2.
                    2.5.1.1.2.2. Команда записывается в оффлайн-файл.
                    2.5.1.1.2.3. Сервер отправляет клиенту-отправителю (клиенту, отправившему команду) ответ 300.
            2.5.1.2. Если type == 1:
                2.5.1.2.1. Таймер для команды с messageID == messageID полученной команды для клиента-отправителя выключается.
                2.5.1.2.2. Если клиент, которому предназначается ответ, есть в списке клиентов:
                    2.5.1.2.2.1. Сервер отправляет клиенту-получателю полученную команду.
                2.5.1.2.3. Если в очереди еще есть таймеры:
                    2.5.1.2.3.1. Сервер заводит следующий таймер.
        2.5.2. Если сервер получает сообщение от таймера:
            2.5.2.1. Сервер удаляет клиента из списка клиентов.
            2.5.2.2. Сервер отключает клиента.
            2.5.2.3. Если в очереди таймеров для этого клиента есть таймеры:
                2.5.2.3.1. Сервер очищает очередь таймеров для этого клиента.
            2.5.2.4. Все команды из буффера неподтвержденных команд для этого клиента изменяются на type=2.
            2.5.2.5. Все команды из буффера неподтвержденных команд для этого клиента записываются в оффлайн-файл.
            2.5.2.6. Отправляется ответ 300 на все команды из буффера неподтвержденных команд.
            2.5.2.7. Поток завершается.
        2.5.3. Если попытка чтения из сокета завершилась ошибкой:
            2.5.3.1. Выполняется пункты 2.5.2.1 - 2.5.2.7.
        2.5.4. Если сервер получает событие по сокету на отключения клиента:
            2.5.4.1. Выполняется пункты 2.5.2.1 - 2.5.2.7.
    2.6. Если сервер получает сигнал о завершении работы:
            2.6.1. Выполняется пункты 2.5.2.1 - 2.5.2.7.
    2.10. Сервер возвращается к пункту 2.5.


## Клиент:

### 1. Начало работы приложения.
    3.1.1. Запуск с указанием адреса и порта сервера, username пользователя и партнера.
    3.1.2. Запись SRC_username.
    3.1.3. Запись partner_username.

### 2. Подключение к серверу.

### 3. Запуск потока принятие команд.
    3.1. Если флаг завершения работы == false:
        3.1.1. Приложение ждет событие по сокету на получение команд.
            3.1.1.1. Приложение получает команду.
                3.1.1.1.1. Если type == 0:
                    3.1.1.1.1.1. Заполняется поле SRC_username.
                    3.1.1.1.1.2. В DST_username указывается SRC_username из пришедшей команды.
                    3.1.1.1.1.3. messageID = messageID пришедшей команды.
                    3.1.1.1.1.4. В message записывается "200".
                    3.1.1.1.1.5. Отправляется ответ серверу на полученную команду.
                    3.1.1.1.1.6. Команда выводится в формате:
                        SRC_username: message0x0a
                3.1.1.1.2. Если type == 1:
                    3.1.1.1.2.1. Команда выводится в формате:
                        SRC_username(messageID): message0x0a
            3.1.1.2. Приложение возвращается к пункту 3.1.
    3.2. Если флаг завершения работы == true:
        3.2.1. Поток завершается.

// {newUsername} - условное обозначение нового имени для отправления.
### 4. Отправка команд.
        4.1. Пользователь вводит сообщение.
        4.2. Если сообщение пользователя начинается на "<newUsername>:":
            4.2.1. partner_username изменяется на <newUsername>.
            4.2.2. "<newUsername>:" очищается из message.
        4.2. Если превышен лимит на размер сообщения:
            4.2.1. Приложение выводит ошибку пользователю.
            4.2.2. Приложение возвращается к пункту 4.1.
        4.3. Собирается команда для отправки.
            4.3.1. len = 24 + длина сообщения.
            4.3.2. type = 0.
            4.3.3. messageID увеличивается на 1.
            4.3.4. Заполняется поле SRC_username.
            4.3.5. DST_username = partner_username.
            4.3.6. Сообщение, набранное пользователем, переносится в message.
        4.4. Команда отправляется серверу.
        4.5. Если в отправленной команде есть символ '~':
            4.5.1. Значение флага завершения работы = true.
            4.5.2. Приложение переходит к пункту 3.5.
        4.6. Если в отправленной команде нету символа '~':
            4.6.1. Приложение возвращается к пункту 4.1.

### 5. Приложение ждет завершения всех дочерних потоков.
### 6. Приложение завершает работу.